# PhysicsControl Plugin Overview

## 1. What this plugin does
- Experimental toolkit for controlling skeletal or static meshes via physics-driven “controls” and “body modifiers”.
- Provides Blueprint components and utility libraries to create, group, and update physical constraints at runtime.
- Ships an editor workflow for authoring Physics Control assets, visualizing controls, and customizing AnimGraph nodes.

## 2. Key Modules
- **PhysicsControl** (Runtime)  
  - Role: Core runtime: control data types, components, assets, Blueprint library, logging, limb helpers.
- **PhysicsControlUncookedOnly** (UncookedOnly)  
  - Role: Editor/PIE-only integrations such as `AnimGraphNode_RigidBodyWithControl` and operator viewer interfaces.
- **PhysicsControlEditor** (Editor)  
  - Role: Asset editors, factories, details customizations, visualizers, and operator viewers for Physics Control assets.

## 3. Important Types & APIs
- `UPhysicsControlComponent`  
  - Role: Main component to create/manage physics controls and body modifiers on meshes.  
  - Key capabilities: create controls (named or autogenerated) between components/bones, bulk creation from skeletal meshes (including constraint profile initialization), limb discovery helpers, control sets, cached target overrides, teleport thresholds, debug visualization toggles, and manual tick methods (`UpdateTargetCaches`, `UpdateControls`).  
  - Provides extensive Blueprint API for creating/destroying controls, enabling/disabling, resetting to cached targets, querying cached bone transforms, and applying control/modifier updates by name/set.
- `UPhysicsControlAsset`  
  - Role: Data asset describing control setups/profiles for reuse; can be referenced by the component to instantiate controls.
- `UPhysicsControlActor`  
  - Role: Convenience actor hosting a Physics Control Component for quick placement/testing.
- `UPhysicsControlBPLibrary`  
  - Role: Blueprint utilities for creating/updating control data, targets, name records, and applying updates.
- `AnimNode_RigidBodyWithControl` / `FAnimNode_RigidBodyWithControl`  
  - Role: Animation node combining rigid-body simulation with Physics Control integration.
- Supporting data structures (`FPhysicsControlData`, `FPhysicsControlTarget`, `FPhysicsControlLimbData`, `FPhysicsControlNameRecords`, `FPhysicsControlRecord`) define drive strengths, targets, limb grouping, and serialization.
- Editor/UI helpers: Operator Viewer widgets, asset editors (`PhysicsControlAssetEditor*` classes), component visualizer, skeleton tree custom items, and details customizations for asset setup/profile/preview.

## 4. Typical usage patterns
- Enable the plugin (and Chaos physics). In the editor, create a Physics Control Asset, edit it via the dedicated asset editor, and assign it to a `UPhysicsControlComponent`.
- Place a Physics Control Actor or add the component to skeletal/static mesh actors.  
  - Use Blueprint or C++ to call `CreateControlsFromSkeletalMesh` / `CreateControlsFromSkeletalMeshAndConstraintProfile` / `CreateControlsFromLimbBones` to generate controls in bulk.  
  - Group controls via sets (e.g., world/parent space or limb sets) for targeted enable/disable/reset operations.  
  - Use `ResetBodyModifierToCachedBoneTransform` or cached bone getters to realign bodies to animation.  
  - For custom tick order, disable component ticking and manually call `UpdateTargetCaches` then `UpdateControls`.
- In animation graphs, use the RigidBodyWithControl node for integrated simulation + control.
- Use editor visualizers/operator viewer to inspect and debug control states in the viewport.

## 5. Version-specific notes (UE 5.7)
- Marked experimental.  
- No explicit 5.7-specific API changes noted; overview reflects current source layout and capabilities.
